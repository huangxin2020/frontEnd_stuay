## 单一职责原则（SRP：Single responsibility principle）

就一个类而言，应该仅有一个引起它变化的原因； 通俗的说，即一个类只负责一项职责

分析：
1. 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力；这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。
2. 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。
3. 如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。

## 开放-封闭原则（OCP：Open Closed Principle）
是说软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改；  
特征1：对于扩展是开放的（Open for extension）；     
特征2：对于更改是封闭的（Closed for modification）。     
分析：
1. 在我们最初编写代码时，假设变化不会发生；当变化发生时，我们就创建抽象来隔离以后发生的同类变化。
2. 面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。
3. 开闭原则是面向对象设计的核心，遵循这个原则会带来一系列好处，可扩展、可复用、可维护、灵活。对频繁变化的部分作出抽象，封装变化。

## 依赖倒转原则
**A.高层模块不应该依赖低层模块。两个都应该依赖抽象**      
**B.抽象不应该依赖细节，细节应该依赖抽象** 

就是要针对接口编程，不要对实现编程     
> 无论主板、CPU、内存都是在针对接口设计的，如果针对实现来设计，内存就要应对到具体的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬。    

关于**A**, 留在**里氏代换原则**中详细描述。

## 里氏代换原则
**子类型必须能够替换掉它们的父类型。**   
> 换句话说，一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而其它察觉不出父类对象和子类对象的区别。
也就是说，在软件里面，把父类都替换成它都替换成它的子类，程序的行为没有变化。

---

1. 正因为有这个原则，使得继承复用成为了可能，
只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。


3. 里氏代换原则是开闭原则、依赖倒置原则的前提，正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。    

* 开闭原则    
当我们在仅有“猫”的情况下，需要扩展“狗”，“牛”，“羊”。在遵守**里氏代换原则**基础上，可以直接通过继承”**动物**“的方式扩展。
![](/images/2019-04-27-18-55-08.png)   

---
* 依赖倒置    
高层元素依赖抽象的接口，而**底层对象可以替换抽象的接口**。这就实现了依赖倒置原则。  
![](/images/2019-04-24-11-55-06.png)

> 针对这上文提到的这一点，举一个例子。你写了很多业务逻辑的代码，你把他们封装成了一个业务逻辑模块。     
在此基础上，你接到了公司里新的业务，需要开发一套新的程序，而新程序与你之前封装的业务逻辑模块几乎一模一样。你打算直接复用。      
但新业务要求使用的数据库系统与之前不同。此时问题就来了：    
> 1. 如果业务逻辑相关的模块直接调用的数据库操作模块。代码里充满了MySqlConnection之类的语句。你想用，就得重写业务逻辑。 
> 2. 但如果你的数据模块里进行了抽象，高层的业务逻辑模块调用的是抽象的接口。你可能只需要改改配置，业务逻辑模块也就直接用了。（想想ORM）


4. 依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即使程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。

## 迪米特法则（LKP：Least Knowledge Principle，又叫最少知识原则）
如果两个类不必彼此直接通信，那么这两个类就不应当直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
分析：
1. 在类的结构设计上，每一个类都应当尽量降低成员的访问权限；
2. 其根本思想是强调了类之间的松耦合；
3. 类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。

## 合成/聚合复用原则
**尽量使用合成/聚合,尽量不要使用类继承**  
优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上；    
这样类和类继承层次会保持较小规模，并且不太可能增长为不可能控制的庞然大物。    
继承是一种强耦合的结构。子类随父类改变而改变，一定要在是‘is-a’的关系在考虑使用。 

---

合成（Composition）和聚合（Aggregation）都是关联的特殊种类；    
聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；    
合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样  

**举个例子：**
![合成聚合](/images/2019-04-24-10-53-03.png)


     
> 建议阅读：桥接模式


## （追加）接口隔离原则
**客户端不应该依赖它不需要的接口；
一个类对另一个类的依赖应该建立在最小的接口上。**

---

一个类对另一个类的依赖应该建立在最小的接口上；     
一个接口代表一个角色，不应该将不同的角色都交给一个接口，因为这样可能会形成一个臃肿的大接口；     
不应该强迫客户依赖它们从来不用的方法。     