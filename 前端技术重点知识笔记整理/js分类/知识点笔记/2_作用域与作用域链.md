# 作用域与作用域链的详细解释

## 什么是作用域与作用域链

在前面的闭包中简单的解释了 - 作用域就是js代码的执行环境再仔细点的说就是浏览器分配给js代码运行的堆栈内存

储存着全局变量(都可以使用的变量)的就是全局作用域 - GO(Global Object)

函数执行时浏览器分配给函数执行的新的、私有的作用域就是私有作用域(函数作用域) - AO(Active Object)

- 函数执行会形成一个私有的作用域，形参和在当前私有作用域中声明的变量都是私有变量，当前的私有作用域有自我保护机制，私有变量和外界是没有关系的，但是如果私有作用域中遇到一个非私有的变量，则向它的上级作用域找，如果还不是上级作用域私有的，则继续向上查找，一直找到window为止。这种变量一层层向上查找的机制就是作用域机制

## 作用域链的特性

当前函数执行，形成一个私有作用域A，A的上级作用域是谁，和他在哪执行的没有关系，和他在哪创建（定义）的有关系，在哪创建的，它的上级作用域就是谁

## 查找作用域链
举例:
```js
var a = 12;
function fn() {
    //=>arguments:实参集合
    //=>arguments.callee:函数本身FN
    //=>arguments.callee.caller:当前函数在哪执行的,caller就是谁(记录的是它执行的宿主环境),在全局下执行caller的结果是NULL
    console.log(arguments.callee.caller);
    // 在实际编程中这两个都不让用
}
function sum() {
    var a = 120;
    fn();
}
function aa() {
    fn();
}
aa();
```
查找规则，先查找自身作用域看看有没有，有就使用自己的，没有就找自己的上一层作用域，直到找到或者一直找到全局作用域中

## 练习题 
重点 ： 引用值是地址操作的
```js
var i = 2;
function fn() {
    i += 2;
    return function (n) {
        console.log(n + (--i));
    }
}
var f=fn();
f(2);
f(3);
fn()(2);
fn()(3);
f(4);
```