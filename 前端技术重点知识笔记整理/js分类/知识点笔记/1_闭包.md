# JS中的闭包机制解释

闭包是JS中特有的一种机制 (一种现象)

主要体现在函数内部可以使用函数外部的的变量

## 理解闭包之前的前置知识

### 作用域与作用域链的部分解释
js代码的执行需要浏览器给它提供一个执行环境来让它执行，这个环境就是作用域。用于存储js代码中的变量、方法等信息。
也可以简单的理解为 - 作用域就是浏览器为js代码执行所提供的堆栈内存空间。
 
作用域也分为全局作用域和私有作用域两种

在ES3/5中的变量提升阶段的时候，存放在浏览器给整个js代码分配的那个堆栈内存中的变量就是全局变量，但是js代码中的函数在执行的时候，浏览器又会为函数分配一个新的私有于这个函数执行的内存空间，这个内存空间就是私有作用域。

而且这个私有作用域与全局作用域存在一个链式联系，这就叫做作用域链

### 全局变量与私有变量
在ES3/ES5 中利用var声明的变量会提升到函数的最上面，function声明的函数会既提升又定义(也就是赋值)

但是ES6中使用Let定义的变量就不会提升变量也没有与window的映射机制

变量也分为全局变量与私有变量两种

私有变量 - 存储在私有作用域中 A:声明过的变量(带VAR/FUNCTION) B:形参也是私有变量

全局变量 - 除了私有之外的其他变量都是全局变量，谁都能使用的变量(基于作用域查找机制)

### 浏览器中的垃圾回收机制 - 堆栈内存释放问题 (ps: 老版的IE不是采用这种方法)
JS中的内存分为堆内存和栈内存
   堆内存：存储引用数据类型值（对象：键值对  函数：代码字符串）
   栈内存：提供JS代码执行的环境和存储基本类型值

 [堆内存释放]
   让所有引用堆内存空间地址的变量赋值为null即可（没有变量占用这个堆内存了，浏览器会在空闲的时候把它释放掉）
   把保存堆内存空间地址的变量重新赋值为null

 [栈内存释放]
   一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉（在栈内存中存储的值也都会释放掉），但是也有特殊不销毁的情况：
   1.函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放（一旦释放外面找不到原有的内容了）
   2.全局栈内存只有在页面关闭的时候才会被释放掉
   ...
   如果当前栈内存没有被释放，那么之前在栈内存中存储的基本值也不会被释放，能够一直保存下来

## 什么是闭包？

- 闭包是函数和声明该函数的词法环境的组合 - MDN中的解释
- js中的一个重要机制，通过函数执行形成一个不销毁的私有作用域(堆栈内存)，既保护了作用域里的变量和信息不被外界影响，又保存了作用域里的信息 - 现在市面上比较通俗的说法也是在笔试和面试的时候说的说法

### 视频上老师的说法
[闭包]
*   函数执行时会形成一个私有的作用域，保护里面的私有变量不受外界的干扰，这种保护机制称之为“闭包”

*   市面上的开发者认为的闭包是：形成一个不销毁的私有作用域（私有栈内存）才是闭包

### js中闭包的写法 - 要求手写闭包时的写法
```js
//=>闭包：柯理化函数
function fn() {
    return function () {

    }
}
var f = fn();

//=>闭包：惰性函数
var utils = (function () {
    return {

    }
})();
```

## 闭包的作用

在JS项目开发中闭包的最主要作用也就是保护 -> 防止全局污染 和 保存信息 -> 事件循环的时候。

闭包项目实战应用

实际发开发中为了保证JS的性能（堆栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的）

### 闭包的实际应用
1.闭包具有“保护”作用：保护私有变量不受外界的干扰
  在真实项目中，尤其是团队协作开发的时候，应当尽可能的减少全局变量的使用，以防止相互之前的冲突（“全局变量污染”），那么 此时我们完全可以把自己这一部分内容封装到一个闭包中，让全局变量转换为私有变量
```js
(function () {
    var n = 12;
    function fn() {

    }
    //...
})(); // 此时在闭包作用域中定义和声明的方法都变成私有的了，不会被外部污染
```
  不仅如此，我们封装类库插件的时候，也会把自己的程序都存放到闭包中保护起来，防止和用户的程序冲突，但是我们又需要暴露一些  方法给客户使用，这样我们如何处理呢？
```js
//1.JQ就是利用这种方式：把需要暴露的方法抛到全局
(function () {
    function jQuery() {
        //...
    }

    //...
    window.jQuery = window.$ = jQuery; //=>把需要供外面使用的方法，通过给WIN设置属性的方式暴露出去
    // 这也是我们可以通过$来使用jquery的原因
})();
jQuery();
$(); // 这两种方法都是可以使用闭包中的JQuery函数

//2.Zepto这种方式：基于RETURN把需要共外面使用的方法暴露出去 Zepto也是一个类似于jQuery的JS库
// 单列模式
var Zepto=(function () {
    //...
    return {
        xxx:function () {

        }
    };
})();
Zepto.xxx();
```
2.闭包具有“保存”作用：形成不销毁的栈内存，把一些值保存下来，方便后面的调取使用

# 在面试中可能会遇到的关于闭包的问题

- 你理解的闭包作用是什么，优缺点？（乐视） 
  + 按照上面的解释来理解 
  + 优点：1.形成私有的作用域保护我们定义的变量和方法不被销毁 2. 防止全局污染和协作开发中的冲突 - 单例方法(单独一个文件详解)

  + 缺点：闭包形成不销毁的堆栈内存会占用堆栈内存影响性能

- 事件循环绑定事件的时候 利用var来定义for循环的变量i就会产生错误
  + 利用ES6中的let
  + 利用闭包
  + 利用自定义属性
```html
<button>点击1</button>
<button>点击2</button>
<button>点击3</button>
```
```js
var btnList = document.querySelectorAll('button'); 
for(var i = 0 ; i < btnList.length ; i++){
   /// 因为当点击事件放生的时候，循环早已结束 所以不管点击那个按钮都是3
   // 使用自定义属性解决 利用属性对象
   // btnList[i].index = i;
   // 自定义的其他方法 - 基于set-attribute是把属性信息写在元素标签的结构上
   btnList[i].setAttribute('data-index', i); // 页面的按钮会增加在元素上
   btnList[i].onclick = function(){
      // 获取自定义属性: 元素对象.属性名 (原理是从堆内存中获取相应的属性值)
      // console.log(this.index + 1)
      console.log(this.getAttribute('data-index'));
   }
}
// Let定义会形成块级作用域
for(let i = 0 ; i < btnList.length ; i++){
    btnList[i].onclick = function(){
        console.log(i);
    }
}
// 利用闭包机制
for(var i = 0 ; i < btnList.length ; i++){
    btnList[i].onclick = (function(i){
        return function(){
            console.log(i);
        }
    })(i)
}
```

以上就是闭包知识的一个大体解释了

# 面试中遇到如何理解闭包的参考回答
谈谈你对闭包的理解
闭包是JS中一个非常重要的机制，我们很多编程思想、业务逻辑、设计模式都是基于闭包完成的，先说一下我对闭包的理解：闭包就是函数执行时产生一个私有的作用域（不销毁），在这个作用域中的私有变量和外界互不干扰，而且作用域（栈）不销毁，这些私有变量存储的值也都保存下来了，所以整体来说闭包就是为了保护和保存变量的
实际项目开发中，很多地方使用到了闭包，例如：
1. 循环事件绑定，由于事件绑定是异步编程的，我们此时在循环的时候把索引存储起来（可以基于自定义属性存储，也可以基于闭包存储），后期需要使用的时候，向上级作用域查找使用即可
2. 平时做业务逻辑的时候，我一般都是基于单例模式来管理代码的，这种单例的构建就应用到了闭包
```js
let xxxRender=(function(){
    return {
        init:function(){

        }
    }
})();
```
3. 我之前在学习资料上了解了柯理化函数思想，它其实也是基于闭包完成的
```js
Function.prototype.bind = function bind(context, ...arg) {
    return () => {
        fn.call(context, ...arg);
    }
};
document.onclick=fn.bind(obj, 10, 20);
```
还有很多地方也应用了闭包，但是闭包比较占内存，我会尽量减少对它的使用，但是有些需求必须要用

## 柯理化函数
1. 执行一个方法，传递一些参数进去，首先形成一个不销毁的栈，把传递的这些值存储起来（没有立即使用，属于预先存储一下）
2. 返回一个小函数给栈外面
3. 当执行返回的小函数时候，把之前第一步预先存储的信息拿过来使用（作用域链、闭包等机制完成的）

我们把JS中基于闭包实现的预先存储的思想成为 “柯理化函数思想”
```js
// 编写一个方法使得 可以把下面的三个函数 变成div2(mul3(add1(add1(0))))这样执行
// 一个函数的结果变成下一个函数的实参
const add1 = (x) => x + 1;
const mul3 = (x) => x * 3;
const div2 = (x) => x / 2;

//=>把数组拼成字符串，把字符串EVAL了即可
// [div2, mul3, add1, add1]
// 'div2(mul3(add1(add1(0))))'
const compose = (...arg) => {//=>不销毁的栈
    //=>arg:[div2, mul3, add1, add1]
    return val => {
        //=>fn(0):执行的是小函数,val=0
        let str = '';
        arg.forEach(item => (str += item.name + ','));
        str = str.replace(/,/g, '(');
        str += val;
        arg.forEach(item => (str += ')'));
        return eval(str);
    }
};
let fn = compose(div2, mul3, add1, add1);
console.log(fn(0));//=>div2(mul3(add1(add1(0))))

// 利用柯理化函数思想
const compose = (...arg) => {
    //=>arg:[div2, mul3, add1, add1]
    arg = arg.reverse();//=>[add1, add1,mul3,div2]
    return val => {
        //=>val:0
        arg.forEach(item => {
            val = item(val);
            //第一次 add1(0) =>1  =>val=1
            //第二次 add1(1) =>2  =>val=2
            //第三次 mul3(2) ...
        });
        return val;
    }
};
let fn = compose(div2, mul3, add1, add1);
console.log(fn(0));//=>div2(mul3(add1(add1(0))))
```