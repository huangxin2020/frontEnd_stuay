# 原型和原型链 - 面试题必考 公共组件

- 所有的对象都是通过```new 函数``` 来创建的
- 所有的函数都是对象
 - 函数中可以有属性
- 所有对象都是引用类型

## 原型 prototype

所有的函数都具有的属性 ：prototype 称之为函数原型 -> 只有函数才有 普通对象没有

prototype默认情况下，是一个普通的Object对象

prototype = {}  默认情况下 prototype中有一个属性，constructor，他也是一个对象，它指向构造函数本身

## 隐式原型 __protot__ 两个下划线

所有的对象都有一个属性：```__proto__```，称之为隐式原型

默认情况下 隐式原型指向创建该对象的函数的原型

当访问一个对象的成员时：

1. 看该对象自身是否拥有该成员，如果有直接访问
2. 在原型链中依次查找看是否拥有该成员，如果有直接使用

**在以后使用构造函数创建对象的时候，对于所有对象都共有的方法应该写在构造函数的prototype中** 

- 猴子补丁: 在函数原型中加入成员，以增强对象的功能 - 会导致原型污染 所有需要谨慎使用

## 原型链

特殊点：

1. Function是直接放入浏览器中的，没有任何东西创建Function 所以 Function的__proto__指向自身的原型prototype
2. object的prototype的__proto__指向null

# 原型链的应用

## 基础方法

W3C不推荐直接使用系统成员__proto__

**Object.getPrototypeOf(对象)**

获取对象的隐式原型

**Object.prototype.inPrototypeOf(对象)**

判断当前对象(this)是否在指定对象的原型链上

**对象 instanceof 函数**

判断函数的原型是否在对象的原型链上 页面上没有iframe时可以使用，否则不建议使用

**Object.create(对象)**

创建一个新对象，其隐式原型指向指定的对象

**Object.prototype.hasOwnPropety(属性名)**

判断一个对象**自身**是否拥有某个属性

## 应用

**把类数组转换为真数组**

```js

Array.from(); - // 最好的方法

Array.prototype.slice.call(类数组) - // call 改变this的指向

[].silce.call(类数组)

第一种方法是最好的

```

**实现继承**

默认情况下，所有的构造函数的父类都是Object

圣杯模式

# 执行上下文 - 执行环境

执行上下文：一个函数**运行之前**，会创建一块运行空间，空间里会包含有该函数执行所需要的数据，为该函数执行提供支持

执行上下文栈: call stack, 所有执行上下文组成的内存空间 栈 ： 先进后出

全局执行上下文：所有的js代码在执行之前，都要具有该环境。

js引擎始终执行的是栈顶的上下文

### 执行上下文的内容

1. this指向

1) 直接调用函数，this指向全局对象
2) 在函数外，this指向全局变量
3) 通过对象调用或new一个函数，this指向调用的对象或者新对象

函数要确定了this指向才能执行

2. vo 变量对象 Variable Object 

记录了该环境中所有声明的参数、变量和函数

Global Object: GO,全局执行上下文中的VO
Active Object: AO,当前正在执行的上下文的VO

1). 确定所有行参值以及特殊变量arguments
2). 确定函数中通过var声明的变量，将他们的值设置为undefined，如果VO中已有该名称，则直接忽略
3). 确定函数中通过字面量声明的函数，将它们的值设置为指向函数对象，如果VO中已存在该名称，则覆盖

当一个上下文中的代码执行的时候，如果上下文中不存在某个属性，则会从之前的上下文中找

# 作用域链

1. VO中包含一个额外的属性，该属性指向创建该VO的函数本身
2. 每个函数在创建时，会有一个隐藏属性```[[scope]]```,它指向创建该函数时的AO
3. 当访问一个变量时，会先查找自身VO中是否存在，如果不存在，则依次查找```[[scoope]]```属性

# 事件循环

Node.js - 会问很多的面试题

异步：某些函数不会立即执行，需要等到某个时机成熟后才会执行，该函数叫做异步函数

浏览器的线程：

1. js执行引擎：负责执行js代码 - 只有它能执行js代码
2. 渲染线程：负责渲染页面
3. 计时器线程：负责计时
4. 事件监听线程：负责监听事件
5. http网络线程：负责网络通信

事件队列: 一块内存空间，用于存放执行时机到达的异步函数。当js引擎空闲 (执行栈没有可执行的上下文)，它会从事件队列中拿出第一个函数执行 - 所以异步代码会在所有的同步代码执行完后才会执行

js中，某个函数的执行过程不能被打断

事件循环：event loop，是指函数在执行栈、宿主线程、事件队列中循环移动